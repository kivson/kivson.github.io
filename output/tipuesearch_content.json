{"pages":[{"text":"Você, como qualquer pessoa, detesta ter que digitar captchas . Elas existem com o suposto pretexto de impedir que softwares automatizados executem ações que degradam a qualidade de um serviço, porém, com isso, eles impedem que outros sistemas façam tarefas automatizadas que facilitem sua vida. Mesmo que esses sistemas não degradem performance alguma. O reconhecimento visual de caracteres se chama OCR , é o que o scanner usa para transformar o documento que você escaneia em texto. Fazer o reconhecimento visual do captcha é mais difícil por que as imagens são distorcidas e obscurecidas para evitar esse tipo de técnica. Vou mostrar a baixo como construir um programa para a leitura automática de captchas, como exemplo vamos usar o captcha do site de enquetes da Câmara Federal , que ficou na mídia nas últimas semanas por causa da enquete sobre o conceito de família . Vale ressaltar que o conteúdo desse post é meramente acadêmico, e você não deve utiliza-lo para fazer coisas ruins, como maltratar gatinhos. Quais os passos? Para quebrar um captcha você seu programa vai precisar fazer três passos . Para o computador cada uma tem um grau natural de dificuldade : Limpar o ruído da imagem (dificuldade média ) Separa os caracteres (essa é a parte difícil ) reconhecer cada caractere (bem fácil ) Do que você precisa? Você vai precisar do seguinte: Python - Interpretador da Linguagem Python Pillow - Biblioteca para lidar com imagens em Python Sklearn - Biblioteca para aprendizado de máquina e inteligencia artificial em Python Skimage - Biblioteca para processamento de imagens Como base para as três últimas você vai precisa também do Numpy e SciPy . Mais informações para instalação, nos respectivos sites. Todas as bibliotecas tem uma excelente documentação. Limpando o ruído Essa parte do processo é totalmente dependente do captcha com o qual se esta lidando. Algumas características da imagem podem facilitar essa atividade: Plano de fundo fixo Cor da letras fixas Ausência de distorções Posição fixa das letras Enfim, quanto mais características dinâmicas a imagem tiver, mais difícil de fazer. Implementação Vamos aos exemplos de imagens: Vamos ao código: def processa_img_teste ( self , img , i = 100 ): sem_linhas = self . remove_linhas ( img ) io . imsave ( \"testes/sem_linhas/teste\" + str ( i ) + \".jpeg\" , sem_linhas ) binaria = self . binariza ( sem_linhas ) io . imsave ( \"testes/bin/teste\" + str ( i ) + \".bmp\" , binaria ) [ ... ] def remove_linhas ( self , img ): #self.remove_linhas_thred=9 filtro = ( np . amax ( img , axis = 2 ) - np . amin ( img , axis = 2 )) < self . remove_linhas_thred img [ filtro , 0 ] = 255 img [ filtro , 1 ] = 255 img [ filtro , 2 ] = 255 return img def binariza ( self , img ): img = np . median ( img , axis = 2 ) . astype ( np . uint8 ) img = ndimage . grey_dilation ( img , size = self . bin_dilatation ) img [ img >= self . threshold ] = 255 img [ img < self . threshold ] = 0 return img Primeiro é feito a remoção das linhas pretas, bem como boa parte do plano de fundo, com o método remove_linhas(self, img) . Nele foi feito um filtro que para cada pixel pega a cor RGB de maior e a de menor intensidade, se a diferença entre essas cores for menor que certo limite ela é transformada em branco. Isso remove o preto e o cinza que esta longe da cor das letras. O método resulta nas imagens: Como eu cheguei nesse método? Testando. Depois disso, aplicado o método binariza(self, img) . Nele a imagem é transformada em tons de cinza . Depois é feita um dilatação morfológica , que expande os pixels cinzas e pretos. Isso nem sempre é necessário, mas nesse caso tornou as imagens mais legíveis. Por fim ela é transforma em uma imagem preta e branca . O resultado: E é isso, a próxima parte continua com a segmentação da imagens em caracteres, a parte divertida =)","tags":"Python","loc":"http://localhost:8000/posts/2014/11/quebrando-o-captcha-das-enquetes-da-camara-parte-1/","title":"Quebrando o captcha das enquetes da Câmara (parte 1)"}]}